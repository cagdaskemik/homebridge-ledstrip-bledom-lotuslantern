<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-10-29T10:48:03.120Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.gitignore
characteristics.js
config.schema.json
Device.js
index.js
package.json
README.md
</repository_structure>

<repository_files>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

package-lock.json
</file>

<file path="characteristics.js">
const { Characteristic } = require("homebridge");

class EffectCharacteristic extends Characteristic {
  constructor() {
    super("Effect", "F0000001-0000-1000-8000-0026BB765291");
    this.setProps({
      format: Characteristic.Formats.UINT8,
      maxValue: 255,
      minValue: 0,
      validValues: [
        0, // None
        0x87, // Jump RGB
        0x88, // Jump RGBYCMW
        0x89, // Crossfade RGB
        0x8a, // Crossfade RGBYCMW
        0x96, // Blink Red
        0x97, // Blink Green
        0x98, // Blink Blue
        0x95, // Blink RGBYCMW
      ],
      perms: [Characteristic.Perms.READ, Characteristic.Perms.WRITE, Characteristic.Perms.NOTIFY],
    });
    this.value = this.getDefaultValue();
  }
}

class EffectSpeedCharacteristic extends Characteristic {
  constructor() {
    super("Effect Speed", "F0000002-0000-1000-8000-0026BB765291");
    this.setProps({
      format: Characteristic.Formats.UINT8,
      unit: Characteristic.Units.PERCENTAGE,
      maxValue: 100,
      minValue: 0,
      minStep: 1,
      perms: [Characteristic.Perms.READ, Characteristic.Perms.WRITE, Characteristic.Perms.NOTIFY],
    });
    this.value = this.getDefaultValue();
  }
}

module.exports = {
  EffectCharacteristic,
  EffectSpeedCharacteristic,
};
</file>

<file path="config.schema.json">
{
    "pluginAlias": "LedStrip",
    "pluginType": "accessory",
    "schema": {
      "type": "object",
      "properties": {
        "name": {
          "title": "Name",
          "type": "string",
          "required": true,
          "default": "LED Strip"
        },
        "uuid": {
          "title": "Device UUID",
          "type": "string",
          "required": true,
          "description": "The UUID of your LED strip (without colons, lowercase)"
        },
        "effect": {
          "title": "Effect Mode",
          "type": "string",
          "required": false,
          "default": "none",
          "oneOf": [
            { "title": "None", "enum": ["none"] },
            { "title": "Jump RGB", "enum": ["JUMP_RGB"] },
            { "title": "Jump RGBYCMW", "enum": ["JUMP_RGBYCMW"] },
            { "title": "Crossfade RGB", "enum": ["CROSSFADE_RGB"] },
            { "title": "Crossfade RGBYCMW", "enum": ["CROSSFADE_RGBYCMW"] },
            { "title": "Blink RGBYCMW", "enum": ["BLINK_RGBYCMW"] }
          ]
        },
        "effectSpeed": {
          "title": "Effect Speed",
          "type": "integer",
          "minimum": 0,
          "maximum": 100,
          "default": 50
        }
      }
    }
  }
</file>

<file path="Device.js">
const noble = require("@abandonware/noble");

const EFFECTS = {
  JUMP_RGB: 0x87,
  JUMP_RGBYCMW: 0x88,
  CROSSFADE_RED: 0x8b,
  CROSSFADE_GREEN: 0x8c,
  CROSSFADE_BLUE: 0x8d,
  CROSSFADE_YELLOW: 0x8e,
  CROSSFADE_CYAN: 0x8f,
  CROSSFADE_MAGENTA: 0x90,
  CROSSFADE_WHITE: 0x91,
  CROSSFADE_RG: 0x92,
  CROSSFADE_RB: 0x93,
  CROSSFADE_GB: 0x94,
  CROSSFADE_RGB: 0x89,
  CROSSFADE_RGBYCMW: 0x8a,
  BLINK_RED: 0x96,
  BLINK_GREEN: 0x97,
  BLINK_BLUE: 0x98,
  BLINK_YELLOW: 0x99,
  BLINK_CYAN: 0x9a,
  BLINK_MAGENTA: 0x9b,
  BLINK_WHITE: 0x9c,
  BLINK_RGBYCMW: 0x95,
};

function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    var hue2rgb = function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function log(message) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}][@cagdaskemik/ledstrip-bledom]:`, message);
}

module.exports = class Device {
  constructor(uuid) {
    this.uuid = uuid;
    this.connected = false;
    this.power = false;
    this.brightness = 100;
    this.hue = 0;
    this.saturation = 0;
    this.l = 0.5;
    this.peripheral = undefined;
    this.write = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.disconnectTimer = null;
    this.isReconnecting = false;

    noble.on("stateChange", async (state) => {
      try {
        if (state === "poweredOn") {
          log("Bluetooth powered on, starting scan...");
          await noble.startScanningAsync();
        } else {
          log(`Bluetooth state changed to: ${state}`);
          if (this.peripheral) {
            await this.peripheral.disconnectAsync();
          }
          this.connected = false;
        }
      } catch (error) {
        log(`Error in stateChange handler: ${error.message}`);
      }
    });

    noble.on("discover", async (peripheral) => {
      try {
        log(`Discovered device: ${peripheral.uuid} - ${peripheral.advertisement.localName}`);
        if (peripheral.uuid === this.uuid) {
          this.peripheral = peripheral;
          await noble.stopScanningAsync();
          log("Found target device, stopped scanning");
        }
      } catch (error) {
        log(`Error in discover handler: ${error.message}`);
      }
    });
  }

  async connectAndGetWriteCharacteristics() {
    try {
      if (this.isReconnecting) {
        log("Already attempting to reconnect, skipping...");
        return;
      }

      this.isReconnecting = true;

      if (!this.peripheral) {
        log("No peripheral found, starting scan...");
        await noble.startScanningAsync();
        return;
      }

      log(`Connecting to ${this.peripheral.uuid}...`);
      await this.peripheral.connectAsync();
      log("Connected successfully");

      const { characteristics } = await this.peripheral.discoverSomeServicesAndCharacteristicsAsync(["fff0"], ["fff3"]);

      if (!characteristics || characteristics.length === 0) {
        throw new Error("No characteristics found");
      }

      this.write = characteristics[0];
      this.connected = true;
      this.reconnectAttempts = 0;

      // Set up disconnect handler
      this.peripheral.once("disconnect", () => {
        log("Device disconnected");
        this.handleDisconnect();
      });
    } catch (error) {
      log(`Connection error: ${error.message}`);
      this.connected = false;
      await this.handleDisconnect();
    } finally {
      this.isReconnecting = false;
    }
  }

  async handleDisconnect() {
    this.connected = false;
    this.write = null;

    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      setTimeout(() => {
        this.connectAndGetWriteCharacteristics();
      }, 5000); // Wait 5 seconds before reconnecting
    } else {
      log("Max reconnection attempts reached. Please check the device.");
      // Reset reconnect attempts after a longer timeout
      setTimeout(() => {
        this.reconnectAttempts = 0;
      }, 60000);
    }
  }

  async writeToDevice(buffer) {
    if (!this.write || !this.connected) {
      await this.connectAndGetWriteCharacteristics();
    }

    return new Promise((resolve, reject) => {
      if (!this.write) {
        reject(new Error("Write characteristic not available"));
        return;
      }

      this.write.write(buffer, true, (err) => {
        if (err) {
          log(`Write error: ${err.message}`);
          reject(err);
        } else {
          this.debounceDisconnect();
          resolve();
        }
      });
    });
  }

  debounceDisconnect() {
    if (this.disconnectTimer) {
      clearTimeout(this.disconnectTimer);
    }

    this.disconnectTimer = setTimeout(async () => {
      if (this.peripheral && this.connected) {
        try {
          log("Disconnecting due to inactivity...");
          await this.peripheral.disconnectAsync();
          log("Disconnected successfully");
          this.connected = false;
        } catch (error) {
          log(`Disconnect error: ${error.message}`);
        }
      }
    }, 5000);
  }

  async set_power(status) {
    try {
      const buffer = Buffer.from(`7e0404${status ? "f00001" : "000000"}ff00ef`, "hex");
      log(`Setting power: ${status}`);
      await this.writeToDevice(buffer);
      this.power = status;
    } catch (error) {
      log(`Set power error: ${error.message}`);
    }
  }

  async set_brightness(level) {
    try {
      if (level > 100 || level < 0) {
        log(`Invalid brightness level: ${level}`);
        return;
      }
      const level_hex = ("0" + level.toString(16)).slice(-2);
      const buffer = Buffer.from(`7e0401${level_hex}01ffff00ef`, "hex");
      log(`Setting brightness: ${level}`);
      await this.writeToDevice(buffer);
      this.brightness = level;
    } catch (error) {
      log(`Set brightness error: ${error.message}`);
    }
  }

  async set_rgb(r, g, b) {
    try {
      const rhex = ("0" + r.toString(16)).slice(-2);
      const ghex = ("0" + g.toString(16)).slice(-2);
      const bhex = ("0" + b.toString(16)).slice(-2);
      const buffer = Buffer.from(`7e070503${rhex}${ghex}${bhex}10ef`, "hex");
      log(`Setting RGB: ${r},${g},${b}`);
      await this.writeToDevice(buffer);
    } catch (error) {
      log(`Set RGB error: ${error.message}`);
    }
  }

  async set_hue(hue) {
    try {
      this.hue = hue;
      const rgb = hslToRgb(hue / 360, this.saturation / 100, this.l);
      await this.set_rgb(rgb[0], rgb[1], rgb[2]);
    } catch (error) {
      log(`Set hue error: ${error.message}`);
    }
  }

  async set_saturation(saturation) {
    try {
      this.saturation = saturation;
      const rgb = hslToRgb(this.hue / 360, saturation / 100, this.l);
      await this.set_rgb(rgb[0], rgb[1], rgb[2]);
    } catch (error) {
      log(`Set saturation error: ${error.message}`);
    }
  }

  async set_effect(effect) {
    try {
      const buffer = Buffer.from(`7e000303${effect.toString(16)}030000ef`, "hex");
      log(`Setting effect: ${effect}`);
      await this.writeToDevice(buffer);
    } catch (error) {
      log(`Set effect error: ${error.message}`);
    }
  }

  async set_effect_speed(speed) {
    try {
      if (speed > 100 || speed < 0) {
        log(`Invalid effect speed: ${speed}`);
        return;
      }
      const speed_hex = ("0" + speed.toString(16)).slice(-2);
      const buffer = Buffer.from(`7e000202${speed_hex}000000ef`, "hex");
      log(`Setting effect speed: ${speed}`);
      await this.writeToDevice(buffer);
    } catch (error) {
      log(`Set effect speed error: ${error.message}`);
    }
  }
};
</file>

<file path="index.js">
const Device = require("./Device");

let Service, Characteristic;

const EFFECTS = {
  JUMP_RGB: 0x87,
  JUMP_RGBYCMW: 0x88,
  CROSSFADE_RGB: 0x89,
  CROSSFADE_RGBYCMW: 0x8a,
  BLINK_RGBYCMW: 0x95,
};

("use strict");
module.exports = function (homebridge) {
  Service = homebridge.hap.Service;
  Characteristic = homebridge.hap.Characteristic;
  homebridge.registerAccessory("@bjclopes/homebridge-ledstrip-bledom", "LedStrip", LedStrip);
};

function LedStrip(log, config, api) {
  this.log = log;
  this.config = config;
  this.homebridge = api;

  this.bulb = new Service.Lightbulb(this.config.name);
  // Set up Event Handler for bulb on/off
  this.bulb.getCharacteristic(Characteristic.On).on("get", this.getPower.bind(this)).on("set", this.setPower.bind(this));
  this.bulb.getCharacteristic(Characteristic.Brightness).on("get", this.getBrightness.bind(this)).on("set", this.setBrightness.bind(this));
  this.bulb.getCharacteristic(Characteristic.Hue).on("get", this.getHue.bind(this)).on("set", this.setHue.bind(this));
  this.bulb.getCharacteristic(Characteristic.Saturation).on("get", this.getSaturation.bind(this)).on("set", this.setSaturation.bind(this));

  this.log("all event handler was setup.");

  if (!this.config.uuid) return;
  this.uuid = this.config.uuid;

  this.log("Device UUID:", this.uuid);

  this.device = new Device(this.uuid);

  this.effect = config.effect || "none";
  this.effectSpeed = config.effectSpeed || 50;
  this.effectService = new Service.Switch(this.config.name + " Effects", "effects");

  this.effectService.getCharacteristic(Characteristic.On).on("get", this.getEffectState.bind(this)).on("set", this.setEffectState.bind(this));
}

LedStrip.prototype = {
  getServices: function () {
    if (!this.bulb) return [];
    this.log("Homekit asked to report service");
    const infoService = new Service.AccessoryInformation();
    infoService.setCharacteristic(Characteristic.Manufacturer, "LedStrip");
    return [infoService, this.bulb];
  },
  getPower: function (callback) {
    this.log("Homekit Asked Power State", this.device.connected);
    callback(null, this.device.power);
  },
  setPower: function (on, callback) {
    this.log("Homekit Gave New Power State" + " " + on);
    this.device.set_power(on);
    callback(null);
  },
  getBrightness: function (callback) {
    this.log("Homekit Asked Brightness");
    callback(null, this.device.brightness);
  },
  setBrightness: function (brightness, callback) {
    this.log("Homekit Set Brightness", brightness);
    this.device.set_brightness(brightness);
    callback(null);
  },
  getHue: function (callback) {
    callback(null, this.device.hue);
  },
  setHue: function (hue, callback) {
    this.log("Homekit Set Hue", hue);
    this.device.set_hue(hue);
    callback(null);
  },
  getSaturation: function (callback) {
    callback(null, this.device.saturation);
  },
  setSaturation: function (saturation, callback) {
    this.log("Homekit Set Saturation", saturation);
    this.device.set_saturation(saturation);
    callback(null);
  },
  getEffectState: function (callback) {
    callback(null, this.effect !== "none");
  },
  setEffectState: function (on, callback) {
    if (on) {
      const effectCode = EFFECTS[this.effect];
      if (effectCode) {
        this.device.set_effect(effectCode);
        this.device.set_effect_speed(this.effectSpeed);
      }
    } else {
      this.effect = "none";
      // Return to normal color mode
      this.device.set_hue(this.device.hue);
    }
    callback(null);
  },
  getServices: function () {
    if (!this.bulb) return [];
    const infoService = new Service.AccessoryInformation();
    infoService.setCharacteristic(Characteristic.Manufacturer, "LedStrip");
    return [infoService, this.bulb, this.effectService];
  },
};
</file>

<file path="package.json">
{
    "name": "@cagdaskemik/homebridge-ledstrip-bledom-lotuslantern",
    "version": "1.1.0",
    "displayName": "Homebridge Ledstrip BLEDOM",
    "description": "",
    "main": "index.js",
    "dependencies": {
        "@abandonware/noble": "^1.9.2-25",
        "prompt-sync": "^4.2.0"
    },
    "keywords": [
        "homebridge-plugin",
        "homebridge-config-ui-x"
    ],
    "engines": {
        "node": ">=12.13.0",
        "homebridge": ">=1.3.0"
    },
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "repository": {
        "type": "git",
        "url": "git+https://github.com/cagdaskemik/homebridge-ledstrip-bledom-lotuslantern.git"
    },
    "author": "",
    "license": "ISC",
    "bugs": {
        "url": "https://github.com/cagdaskemik/homebridge-ledstrip-bledom-lotuslantern/issues"
    },
    "homepage": "https://github.com/cagdaskemik/homebridge-ledstrip-bledom-lotuslantern#readme"
}
</file>

<file path="README.md">
# homebridge-ledstrip-bledom

This plugin let you control RGB Bluetooth-enabled "ELK-BLEDOM" LED light strips, that are compatible with the Lotus Lantern app.

Control On/Off, Hue, Saturation and Brightness.

## Prerequisite
You need to have a bluetooth device. Check using `hcitool dev` command. You may also need root access with Homebridge

To run without root access, go to homebridge terminal and type ```sudo setcap cap_net_raw+eip $(eval readlink -f `which node`)```

## Installation

`npm i @bjclopes/homebridge-ledstrip-bledom`

## Configuration
```js
{
    "accessory": "LedStrip", // Dont change
    "name": "LED", // Accessory name
    "uuid": "be320202f8e8" // BLE device UUID
}
```

To find your device uuid, use `hcitool lescan`, grab the device uuid, remove all ':' and use lowercase alpha characters

## Contribution
This package is basen on the work of [Lylya](https://github.com/Lyliya) on the project [homebridge-ledstrip-ble](https://github.com/Lyliya/homebridge-ledstrip-ble/).
The new configuration parameters are based on the work of [user154lt](https://github.com/user154lt) on the project [ELK-BLEDOM-Command-Util](https://github.com/user154lt/ELK-BLEDOM-Command-Util).

You can contribute by creating merge request, you can find a documentation of the BLE message used here : [Documentation](https://github.com/arduino12/ble_rgb_led_strip_controller/blob/master/README.md)
</file>

</repository_files>
